`timescale 1ns / 1ps

/* 
 * Verification Requirements:
 * Simple testbench used to check that the output clock generated by the RGMII_Phy_if module is accurate 
 * based on the clck frequency needed. Additionally, the testbench ensures the txd and txctl lines are also
 * correctly driven.
 */

module rgmii_phy_if_tb;

//Local variables
localparam LINK_10 = 2'b00;
localparam LINK_100 = 2'b01;
localparam LINK_1000 = 2'b10;

//Signal Declarations
logic clk_125;                       //125MHz MAC Domain Clock 
logic clk90;                         //125MHz clock with a 90 degree phase shift (Used for TXC)
logic reset_n;                       //Active low reset signal
/* PHY Interface */
logic rgmii_phy_rxc;                 //recieved clock from the PHY
logic [3:0] rgmii_phy_rxd;           //recieve data line from PHY
logic rgmii_phy_rxctl;               //receieve control siganl from PHY
logic rgmii_phy_txc;                //clock that drives txdata to PHY
logic [3:0] rgmii_phy_txd;          //tx data driven to PHY
logic rgmii_phy_txctl;              //tx control signal driven to PHY
/* MAC Interface */
logic [7:0] rgmii_mac_tx_data;       //tx data to transmit to the PHY
logic rgmii_mac_tx_dv;               //tx data valid signal - used for the rxctl        
logic rgmii_mac_tx_er;               //tx data error - used for rxctl
logic rgmii_mac_tx_rdy;              //Signal to indicate new data can be driven from MAC
logic  rgmii_mac_rx_clk;             //RX PHY clock
logic  [7:0] rgmii_mac_rx_data;      //Data recieved from PHY
logic  rgmii_mac_rx_dv;              //RX data valid signal - driven on the posedge of the rxctl signal
logic  rgmii_mac_rx_er;              //RX error signal - falling edge of rxc drives error XOR data_valid
logic [1:0] link_speed;          

//variables
int rxc_prd;

//Module Instantiation
rgmii_phy_if rgmii_if(.*);

//Initialize clocks - both have 125MHz freq (8ns period)
always #4 clk_125 = ~clk_125;
always #(rxc_prd/2) rgmii_phy_rxc = ~rgmii_phy_rxc;

//Drive signals on the data line to the rgmii at DDR/SDR
always @(posedge rgmii_phy_rxc)
    rgmii_phy_rxd = $urandom_range(0, 16);

//Only drive on falling edge if we are in Gbit mode
always @(negedge rgmii_phy_rxc)
    if(rxc_prd ==  8)
        rgmii_phy_rxd = $urandom_range(0, 16);

//Property to ensure that the ctrl signal drives teh dv signal on rising edge of tx clock
property tx_ctl_dv;
    @(posedge rgmii_phy_txc)
    disable iff(!reset_n)                       //Disable assertion is reset is low
    rgmii_phy_txctl == rgmii_mac_tx_dv;         //Ensure control signal is always equievelent to dv on rising edge
endproperty

property tx_data_rdy;
    @(negedge rgmii_phy_txc)
    disable iff(!reset_n)                       //Disable assertion is reset is low 
    (rgmii_mac_tx_rdy == 1'b1);                 //After data transmission tx_rdy shoudl always be low
endproperty

//Used to select the rgmii clk freqneyc based on bandwidth
always @(link_speed) begin
    case(link_speed) 
        //10Mbps has 2.5 MHz (400ns)
        LINK_10 : rxc_prd = 400;
        //100Mbps has 25MHz (40ns)
        LINK_100 : rxc_prd = 40;
        //1Gbit has 125MHz (8ns)
        LINK_1000 : rxc_prd = 8;
    endcase
end 

//Task used to simulate data transmission & use immedaite assertions to ensure correct clock period
task transmit_data(input logic [1:0] _link_speed);
    int start_time, current_time;
    
    link_speed = _link_speed;
    for(int i = 0; i < 10; i++) begin
        //Randomize/generate data to transmit
        randomize(rgmii_mac_tx_data, rgmii_mac_tx_dv, rgmii_mac_tx_er);
        
        //10Mbps
        if(link_speed == LINK_10) begin
            @(posedge rgmii_mac_tx_rdy);  
            start_time = $time;
            
            //Assertion to ensure data output is correct
            assert(rgmii_phy_txd == rgmii_mac_tx_data[3:0]) 
                else $fatal(2, "Data Mismatch [1] for 10Mbps bandwidth: Data expected: %0h Data Read: %0h", rgmii_mac_tx_data[3:0], rgmii_phy_txd);
            
            rgmii_mac_tx_data = rgmii_mac_tx_data >> 4;             
            @(posedge rgmii_mac_tx_rdy);
            current_time = $time; 
            
            //Assertion to ensure data output is correct 
            assert(rgmii_phy_txd == rgmii_mac_tx_data[3:0]) 
                else $fatal(2, "Data Mismatch [2] for 10Mbps bandwidth: Data expected: %0h Data Read: %0h", rgmii_mac_tx_data[3:0], rgmii_phy_txd);
            
            //Check the accuracy of the clock period with immediate assertion
            assert(current_time-start_time == 400) else $fatal(2, "2.5MHz period failed");
        end 
        //100Mbps
        else if(link_speed == LINK_100) begin
            @(posedge rgmii_mac_tx_rdy);  
            start_time = $time;
            
            //Assertion to ensure data output is correct
            assert(rgmii_phy_txd == rgmii_mac_tx_data[3:0]) 
                else $fatal(2, "Data Mismatch [1] for 100Mbps bandwidth: Data expected: %0h Data Read: %0h", rgmii_mac_tx_data[3:0], rgmii_phy_txd);
            
            rgmii_mac_tx_data = rgmii_mac_tx_data >> 4; 
            @(posedge rgmii_mac_tx_rdy);
            current_time = $time;  
            
            //Assertion to ensure data output is correct 
            assert(rgmii_phy_txd == rgmii_mac_tx_data[3:0]) 
                else $fatal(2, "Data Mismatch [2] for 100Mbps bandwidth: Data expected: %0h Data Read: %0h", rgmii_mac_tx_data[3:0], rgmii_phy_txd);
            
            //Check the accuracy of the clock period with immediate assertion
            assert(current_time-start_time == 40) else $fatal(2, "25MHz period failed");           
        end 
        //1000Mbps
        else begin
            //At 125MHz, the data rdy signal is always set, therefore data is transmitted continously - additioanlly,
            //data transmission occurs at DDR, therfore both the pos and neg edge of the clock must be monitored
            @(posedge rgmii_phy_txc);            
            start_time = $time; 
            
            //Assertion to ensure data output is correct
            assert(rgmii_phy_txd == rgmii_mac_tx_data[3:0]) 
                else $fatal(2, "Data Mismatch [1] for 1000Mbps bandwidth: Data expected: %0h Data Read: %0h", rgmii_mac_tx_data[3:0], rgmii_phy_txd);
            
            @(negedge rgmii_phy_txc);
            
            //Assertion to ensure data output is correct
            assert(rgmii_phy_txd == rgmii_mac_tx_data[7:4]) 
                else $fatal(2, "Data Mismatch [2] for 1000Mbps bandwidth: Data expected: %0h Data Read: %0h", rgmii_mac_tx_data[7:4], rgmii_phy_txd);     
            
            //used to check the falling edge control signal (only in 1000Mbps mode)
            assert(rgmii_phy_txctl == (rgmii_mac_tx_dv ^ rgmii_mac_tx_er))
                else $fatal(2, "Tx ctl failed to drive the (dv XOR er) signal on rising edge");          
            current_time = $time;   
            
            //Check the half period (time clock is high) is 4ns
            assert(current_time-start_time == 4) else $fatal(2, "125MHz period failed");               
        end
    end
endtask : transmit_data

/** Concurrent Assertion(s) **/
assert property(tx_ctl_dv)
    else $fatal(2, "Tx ctl failed to drive the data valid signal on rising edge");      
    
assert property(tx_data_rdy)
    else $fatal(2, "Tx ready signal not raised after data transmission");   
    
//Implement 90 degree phase shift for clk90
initial begin
    rxc_prd = 8;
    clk_125 = 1'b0;
    rgmii_phy_rxc = 1'b0;
    #2 clk90 = 1'b0;
    forever #4 clk90 = ~clk90;
end

initial begin
    
    //Init/Reset signals
    reset_n = 0; #40; 
    reset_n = 1; #10;
    
    /* Test 1 : Link Bandwidth of 10Mbps (2.5MHz rxc) */
     transmit_data(LINK_10);
    
    /* Test 2 : Link Bandwidth of 100Mbps (25MHz rxc) */
    transmit_data(LINK_100);
  
    /* Test 3 : Link Bandwidth of 1000Mbps (125MHz rxc) */
    transmit_data(LINK_1000);
    
    /* Test 4 : Link Bandwidth of 100Mbps (25MHz rxc) */
    transmit_data(LINK_100); 
    
    /* Test 5 : Link Bandwidth of 10Mbps (2.5MHz rxc) */
     transmit_data(LINK_10);    
    
    $finish;  
end


endmodule
